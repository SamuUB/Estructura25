; Autor: Samuel Muñoz-Guerra Gómez
; --------- MACROS ---------
LEA: MACRO(reg, ETIQ)
    or reg, r0, low(ETIQ)
    or.u reg, reg, high(ETIQ)
ENDMACRO

LOAD: MACRO(reg, ETIQ)
    LEA(reg, ETIQ)
    ld reg, r0, reg
ENDMACRO

PUSH: MACRO(ra)
    subu r30, r30, 4
    st ra, r30, 0
ENDMACRO

POP: MACRO(ra)
    ld ra, r30, 0
    addu r30, r30, 4
ENDMACRO

org 0x1000
ppal: 
    LEA(r30, 0xF000)                                ; Inicializar puntero de pila (r30 = 0xF000)

BancoPruebasDesComprime:
    LEA(r10,comprimido)
    PUSH(r10)
    LEA(r10,cadena)
    PUSH(r10)
    bsr Comprime
    POP(r10)
    POP(r10)
Descomprimidisimo:    
    LEA(r10,descomprimido)
    PUSH(r10)
    LEA(r10,comprimido)
    PUSH(r10)
    bsr Descomprime
    POP(r10)
    POP(r10)
finPPAL:
    stop                                            ; Detener ejecución


PoneBitA1:                                          
    ; PoneBitA1(dirZonaCB, NumBit)
    ; r10 = dirZonaCB (dir del campo de bits)
    ; r11 = NumBit (numero bit a activar)
    ; r12 = byteOffset
    ; r18 = 8 × byteOffset (para calcular posicion bit dentro del byte)
    ; r13 = posición del bit dentro del byte (de 7 a 0)
    ; r14 = constante 7 
    ; r3  = mascara con el bit deseado activado
    ; r4  = constante 2 (para desplazar máscara)
    ; r7  = registro para comparaciones
    ; r16 = dir del byte a modificar (dirZonaCB + byteOffset)
    ; r17 = contenido del byte leido y despues actualizado

    PUSH    (r1)                                    
    PUSH    (r31)                                   
    or      r31, r30, r0                             ; Marco de pila

    ; Cargar parámetros
    ld      r10, r31, 8                              ; r10 = dirZonaCB
    ld      r11, r31, 12                             ; r11 = NumBit         

    ; byteOffset 
    divs     r12, r11, 8                            ; r12 = NumBit / 8      

    ; Obtener NumBit dentro del byte correspondiente
    or r18,r0,8
    mulu r18,r18,r12                                                        
    subu r13,r11,r18                                                        
    or r14, r0, 7                                   ; r14 = 7
    subu r13, r14, r13                              ; r13 = 7 - r13 => posición de bit en el byte

    ; Preparar mascara
    or r3,r0,1                                      ;r3 = 1
    or r4,r0,2                                      ;r4 = 2

    BuclePBA1:
    cmp r7,r13,r0                                   ; Comprobamos si estamos en NumBit
    bb1 eq,r7,PBA1                                  ; Si estamos => PBA1 
    muls r3,r4,r3                                   ; Desplazamos r3 un bit a la izqda
    subu r13,r13,1                                  ; Decrementamos contador de NumBit
    br BuclePBA1                                    
    
    ; Leer byte actual, modificarlo y almacenarlo
    PBA1:
    ld.bu r17, r10, r12                              ; r17 = contenido byte actual (lectura)

    or r17, r17, r3                                 ; r17 = byte actualizado  (poner el bit r11 a 1)
    st.b r17, r10, r12                                ; Escribir byte modificado en memoria

    ; Restaurar pila y retornar
    POP(r31)
    POP(r1)
    jmp (r1)                                        ; Retorno
BuscaCar:
    ; BuscaCar (C,ref,from, to)
    ; Registros usados:
    ; r3  = C (caracter a buscar)
    ; r4  = ref (direccion de la cadena)
    ; r5  = from (posicion inicial)
    ; r6  = to (posicion final o tope)
    ; r7  = registro de comparación
    ; r29  = puntero al índice actual
    ; r9  = Dir ref[from + i]
    ; r10 = caracteres que se van leyendo de la cadena
    ; r29 = valor de retorno (posición encontrada o to)

    PUSH(r1)
    PUSH(r31)

    or      r31, r30, r0           ; Marco de pila
    ld      r3, r31, 8        ; C <= carácter a buscar
    ld      r4, r31, 12       ; ref <= Dir de cadena
    ld      r5, r31, 16       ; from <= inicio
    ld      r6, r31, 20       ; to <= fin

    or      r29, r5, r0        ; índice actual = from

    bucle_BC:
    cmp     r7, r29, r6          ; ¿hemos llegado a to?
    bb1     eq, r7, fin_BC      ; Si hemos llegado => fin_BC
    ld.bu   r10, r4, r29          ; r10 <= carácter actual
    cmp     r7, r10, r3         ; ¿carácter actual == C?
    bb1     eq, r7, fin_BC
    addu    r29, r29, 1           ; avanzar índice
    br      bucle_BC

    fin_BC:
    POP(r31)
    POP(r1)
    jmp(r1)
LongCad:
    ; LongCad (cadena)
    ; r10 = *cadena (dir de inicio)
    ; r3  = caracteres que se van leyendo de la cadena
    ; r7  = comparación con 0 (detecta fin de cadena)
    ; r29 = contador de longitud (valor de retorno)
    
    PUSH    (r1)                    
    PUSH    (r31)
    or      r31,r30,r0                  ; Marco de pila
    ld      r10,r31,8                   ; Cargar dir de la cadena
    or      r29, r0, r0                 ; Inicializar contador en 0

    bucle_longcad:
    ld.bu   r3, r10, 0                  ; Cargar byte (carácter)
    cmp     r7, r3, r0
    bb1     eq, r7, fin_longcad         ; Si es 0, fin de cadena
    addu    r29, r29, 1                 ; Incrementar contador
    addu    r10, r10, 1                 ; Avanzar al siguiente carácter
    br      bucle_longcad               ; Repetir

    fin_longcad:
    or      r30,r31,0
    POP     (r31)
    POP     (r1)                        ; Restaurar dir de retorno
    jmp     (r1)                        ; Volver a la rutina llamante
CoincidenCad:
    ; CoincidenCad(cadena1, cadena2)
    ; r10 = *cadena1 (dir de inicio)
    ; r11 = *cadena2 (dir de inicio)
    ; r3  = caracteres que se van cargando de cadena1
    ; r4  = caracteres que se van cargando de cadena2
    ; r7  = Comparaciones (fin cadenas o !(coinciden caracteres))
    ; r29 = contador de carcateres coincidentes (valor de retorno)
    
    PUSH    (r1)
    PUSH    (r31)

    or      r31, r30, r0                ; Marco de pila
    ld      r10, r31, 8                 ; Cargamos cadena1
    ld      r11, r31, 12                ; Cargamos cadena2
    or      r29, r0, r0                 ; Inicializamos contador

    bucle_CC:
    ld.bu   r3, r10, 0                  ; Cargamos byte de cadena 1(Car1)
    ld.bu   r4, r11, 0                  ; Cargamos byte de cadena 2(Car1)
    cmp     r5, r3, r0                  ; Comprobamos si final cadena 1
    bb1     eq, r5, fin_CC              ; Si Car1 = null => fin_CC
    cmp     r6, r4, r0                  ; Comprobamos si final cadena 2
    bb1     eq, r6, fin_CC              ; Si Car2 = null => fin_CC
    cmp     r7, r3, r4                  ; Comprobamos Car1 = Car2
    bb1     ne, r7, fin_CC              ; Si Car1 != Car2 => fin_CC
    addu    r29, r29, 1                 ; Si todo correcto aumentamos en 1 el contador
    addu    r10, r10, 1                 ; *r10 = siguiente carácter de cadena 1
    addu    r11, r11, 1                 ; *r11 = siguiente carácter de cadena 2
    br      bucle_CC

    fin_CC:
    POP     (r31)
    POP     (r1)
    jmp     (r1)

Verifica:
    jmp (r1)
Comprime:
    ; ==============================================================================
    ; SUBRUTINA: Comprime
    ; ==============================================================================
    ; INPUT:
    ;   [r31+8]  : Dir Texto Original
    ;   [r31+12] : Dir Texto Comprimido
    ;
    ; OUTPUT:
    ;   r29       : Longitud total en bytes del resultado comprimido.
    ; --------------------------------------------------------------------------
    ; 1. Crear marco de pila y salvar registros del llamante
    ; --------------------------------------------------------------------------
    
    PUSH    (r1)
    PUSH    (r31)
    or      r31, r30, r0

    ; --------------------------------------------------------------------------
    ; 2. Calculo de la longitud de la cadena original
    ; --------------------------------------------------------------------------
    
    ld      r10, r31, 8         ; r10 = Dir Texto Original
    
    PUSH    (r10)               ; Pasamos dir texto original
    bsr     LongCad             ; r29 = longitud texto original
    POP     (r10)               ; recuperar registros importantes

    or      r3, r29, r0         ; r3 = Longitud Texto Original

    ; --------------------------------------------------------------------------
    ; 3. Inicializacion de Variables y de la Cabecera
    ; --------------------------------------------------------------------------
    
    ld      r11, r31, 12        ; Cargar argumento: Dir Salida
    st.h    r3,  r11, 0         ; bytes 0 y 1: Longitud Original
    
    or      r8,  r0, 1          ; M = 1
    st.b    r8,  r11, 2         ; Byte 2: M
    mulu    r8,  r8, 8          ; r8 = 8*M
    or      r9,  r0, 4          ; r9 = N (El umbral para la compresión)

    ; Calcular parámetros del Mapa de Bits
    
    addu    r12, r11, 5         ; r12 = Inicio datos MapaBits (Offset 5)
    
    subu    r20, r3, r8         ; r20 = (Longitud - 8) => Bits necesarios
    subu    r20, r20, 4
    addu    r21, r20, 7         ; r21 = Num_Bits + 7 (Para redondear)
    divu    r21, r21, 8         ; r21 = Bytes para MapaBits       
    
    ; --------------------------------------------------------------------------
    ; 4. Limpiar Mapa de Bits (Poner a 0)
    ; --------------------------------------------------------------------------
    
    or      r24, r0, r0         ; i = 0 
    init_mapa:
    cmp     r7, r24, r21        ; while (i < Tamño Mapa Bits)
    bb1     ge, r7, fin_init_mapa
    st.b    r0, r12, r24        ; Mapa[i] = 0
    addu    r24, r24, 1         ; i++
    br      init_mapa
    fin_init_mapa:
    or      r4,r0,r0            ; Contador Tamño MapaBits
    
    ; --------------------------------------------------------------------------
    ; 5. Reservar memoria en la pila para Zona3 (Debe estar alineada a 4 bytes)
    ; --------------------------------------------------------------------------
    
    or      r22, r3, r0         ; Tamaño base = Longitud Texto (Peor caso)
    and     r23, r22, 3         ; Aplicamos máscara (Es el resto de la division entre 4)
    cmp     r7, r23, r0         ; r23 = 0 => r23 multiplo de 4
    bb1     eq, r7, zona3_ok
    
    ; Si no está alineada: Tam_texto - resto de dividir por 4 (Anterior multiplo de 4)
    subu    r22, r22, r23       ; r22 = Anterior multiplo de 4
    addu    r22, r22, 4         ; Sumo 4 para redondear a la alza
    zona3_ok:
    subu    r30, r30, r22       ; Reservamos el Tamño acorde al peor caso (no hay compresion)
    or      r16, r30, r0        ; r16 = Puntero a Zona3

    ; --------------------------------------------------------------------------
    ; 6. Copia inicial de carcateres (Primeros 8*M caracteres)
    ; --------------------------------------------------------------------------
    or      r13, r0, r0         ; Indice Texto = 0
    or      r14, r0, r0         ; Indice Zona3 = 0
    or      r15, r0, r0         ; Indice Bit   = 0

    bucle_copia:
    cmp     r7, r13, r8         ; while (i < M*8)
    bb1     ge, r7, bucle_principal
    ld.bu   r25, r10, r13       ; Leer caracter del texto original
    st.b    r25, r16, r14       ; Escribir caracter en Zona3
    addu    r13, r13, 1         ; i++
    addu    r14, r14, 1         ; j++
    br      bucle_copia

    ; ==========================================================================
    ; 7. Bucle principal de compresion
    ; ==========================================================================
    ; 7.1. Comprobamos si final de la cadena original
    ; 7.2. Llamamos a BuscaMax para buscar cadenas repetidas
    ; 7.2.1 Reservamos espacio para variable jj
    ; 7.2.2 Llamamos a BuscaMax y guardamos el valor de jj
    ; 7.2.3 Limoiamos espacio reservado a jj
    ; 7.3. Decidir si comprimir o no
    ; Si comprime:
    ;   1. Ponemos bit r15 a 1
    ;   2. Guardamos P (2 bytes) y L (1 byte) en Zona3
    ; Si NO comprime:
    ;   1. Copiar caracter de la cadena original
    ; ==========================================================================

    bucle_principal:
    cmp     r7, r13, r3         ; while (i < LongitudOriginal)
    bb1     ge, r7, fin_bucle

    ; ----------------------------------------------------------------------
    ; Guardamos registros importantes
    ; ----------------------------------------------------------------------
    
    PUSH    (r3)                ; Longitud Texto Original
    PUSH    (r4)                ; Contador Tmño Mapa Bits
    PUSH    (r9)                ; N
    PUSH    (r12)               ; Dir Mapa Bits
    PUSH    (r13)               ; Indice texto original
    PUSH    (r14)               ; Indice Zona3
    PUSH    (r15)               ; Indice Num Bit del Mpa de Bits

    ; ----------------------------------------------------------------------
    ; Llamar a BuscaMax
    ; ----------------------------------------------------------------------
    subu    r30, r30, 4         ; Espacio para jj (output de BuscaMax)
    or      r26, r30, r0        ; r26 = &jj

    PUSH(r26)                   ; Puntero a variable donde dejar P
    PUSH(r13)                   ; Posición actual (MAX)
    PUSH(r10)                   ; Dir inicio Texto
    
    bsr     BuscaMax            ; r29 = L, [r26] = P
    
    POP     (r10)               ; Recuperar
    POP     (r13)
    POP     (r26)

    ld      r28, r26, 0         ; Guardar valor de P 
    addu    r30, r30, 4         ; Liberar jj

    ; ----------------------------------------------------------------------
    ; Restauramos registros importantes
    ; ----------------------------------------------------------------------

    POP     (r15)
    POP     (r14)
    POP     (r13)
    POP     (r12)
    POP     (r9)
    POP     (r4)
    POP     (r3)
    
    ; ----------------------------------------------------------------------
    ; Decision: comprimir o copiar (Comprimimos si L >= N )
    ; ----------------------------------------------------------------------
    cmp     r7, r29, r9         ; Si (L < 4) => No comprimir
    bb1     lt, r7, no_comprime 
    addu    r4, r4, r29         ;Contador caracteres Mapa Bits ++

    ; Si comprimimos Bit[r15] = 1
    PUSH    (r3)                ; |
    PUSH    (r4)                ; |
    PUSH    (r10)               ; | Registros importantes
    PUSH    (r13)               ; |
    PUSH    (r14)               ; |
    PUSH    (r15)               ; NumBit
    PUSH    (r12)               ; DirZonaCB
    bsr     PoneBitA1
    POP     (r12)                    
    POP     (r15)
    POP     (r14)
    POP     (r13)
    POP     (r10)
    POP     (r4)
    POP     (r3)
    
    ; ----------------------------------------------------------------------
    ; Guardamos P (2 bytes) y L (1 byte) en Zona3
    ; ----------------------------------------------------------------------

    ; 1. Escribir Byte Bajo (LSB) en offset r14
    st.b    r28, r16, r14
    
    ; 2. Calcular y Escribir Byte Alto (MSB) en offset r14 + 1
    or      r24, r0, 256        ; r24 = divisor temporal
    divu    r24, r28, r24       ; r24 = r28 / 256 (Desplazamos >> 8)
    addu    r23, r14, 1
    st.b    r24, r16, r23

    addu    r14, r14, 2         ; j += 2
    st.b    r29, r16, r14       ; Guardar L (1 byte)
    addu    r14, r14, 1         ; j += 1

    ; Actualizar Índices
    addu    r13, r13, r29       ; i += L (Avanzamos L caracteres)
    addu    r15, r15, 1         ; k ++   (Siguiente bit)
    
    br      bucle_principal

    no_comprime:
    ; Si no comprimimos     =>  Copiamos carcater
    
    ld.bu   r25, r10, r13       ; Cargar char original
    st.b    r25, r16, r14       ; Guardar en Zona3
    
    addu    r13, r13, 1         ; i++
    addu    r14, r14, 1         ; j++
    addu    r15, r15, 1         ; k++
    
    br      bucle_principal

    fin_bucle:    
    ; --------------------------------------------------------------------------
    ; 8. Guardamos Tamño de MapaBits en cabecera y calculamos dir zona3
    ; --------------------------------------------------------------------------
    ; 1. Escribir Byte Bajo (LSB) en offset 3
    ld      r11, r31, 12        ; r11 = dir cadena comprimida
    addu    r15, r15, 7         ; Sumamos 7 al num bits usados (Tmño cadena original - longitud comprimida)
    divu    r15, r15, 8         ; Calculamos eso en bytes
    addu    r15, r15, 5         ; Le sumamos la longitud de la cabecera
    st.b    r15, r11, 3         ; Guardamos en los bytes 3 y 4 de la cabecera
    
    ; 2. Calcular y Escribir Byte Alto (MSB) en offset 4
    or      r24, r0, 256        ; Usamos r24 como divisor temporal
    divu    r24, r15, r24       ; r24 = r4 / 256 (Desplazamiento >> 8)
    st.b    r24, r11, 4
    
    addu    r25, r11, r15       ; r25 = dir Zona3 (dir cadena comprimida + offset correspondiente)
    or      r24, r0, r0         ; Contador = 0
    ; --------------------------------------------------------------------------
    ; 9. Copiamos zona3 en la direccion correspondiente
    ; --------------------------------------------------------------------------

    copiar_zona3:
    cmp     r7, r24, r14        ; while (contador < longitud_zona3)
    bb1     ge, r7, fin_zona3
    
    ld.bu   r27, r16, r24       ; Leer caracter de Zona3 (Pila)
    st.b    r27, r25, r24       ; Escribir cacracter en cadena comprimido
    
    addu    r24, r24, 1
    br      copiar_zona3
    fin_zona3:

    ; --------------------------------------------------------------------------
    ; 10. Calculo valor de retorno
    ; --------------------------------------------------------------------------
    addu    r29,r14,r15         ; r29 = Tamño cadena comprimida (Cabecera y Mapa Bits incluidos)
    ; Liberar pila (Zona3)
    or      r30, r31, r0        ; Restaurar SP al marco original (libera todo lo allocado)
    
    POP     (r31)               ; Restaurar Frame Pointer anterio
    POP     (r1)                ; Restaurar Retorno
    jmp     (r1)                ; Volver a casa
Descomprime:
    PUSH    (r1)
    PUSH    (r31)
    or      r31, r30, r0                ; Marco de pila

    ld      r10, r31, 8                 ; r10 = comprimido
    ld      r11, r31, 12                ; r11 = descomprimido

    ld.hu   r2, r10, r0                 ; r2 = longitud texto original
    ld.bu   r3, r10, 2                  ; r3 = M
    mulu    r3, r3, 8                   ; r3 = carcateres a copiar sin comprimir
    
    ld.bu   r24, r10, 3                 ; r24 = byte en offset 3 (MSB)
    ld.bu   r25, r10, 4                 ; r25 = byte en offset 4 (LSB)
    mulu    r25, r25, 256               ; r25 << 8
    addu    r4, r24, r25                ; r4 = (alto<<8) + bajo  = valor de los bytes 3 y 4
    addu    r4, r10, r4                 ; r4 = dir_zona3 = *cmprmdo + desplazamiento
    
    or      r12, r0, r0                 ; r12 = Indice texto descomprimido
    or      r13, r0, r0                 ; r13 = Indice MapaBits
    or      r14, r0, r0                 ; r14 = Indice en zona3

    bucle_copia_desc:
    cmp     r7, r12, r3
    bb1     eq, r7, fin_copia_desc
    ld.bu   r15, r4, r12
    st.b    r15, r11, r12
    addu    r12, r12, 1
    addu    r14, r14, 1
    br      bucle_copia_desc
    fin_copia_desc:
    addu    r3, r10, 5                  ; r3 = *MapaBits
    
    bcle_prncp_desc:
    ld.bu   r15, r4, r14
    cmp     r7, r15, r0
    bb1     eq, r7, fin_bucle_desc
    cmp     r7, r2, r12
    bb1     eq, r7, fin_bucle_desc

    PUSH    (r2)
    PUSH    (r4)
    PUSH    (r10)
    PUSH    (r11)
    PUSH    (r12)
    PUSH    (r14)
    PUSH    (r15)

    PUSH    (r13)                       ; NumBit
    PUSH    (r3)                        ; dirZonaCB (*MapaBits)
    bsr     LeeBit
    POP     (r3)
    POP     (r13)

    POP     (r15)
    POP     (r14)
    POP     (r12)
    POP     (r11)
    POP     (r10)
    POP     (r4)
    POP     (r2)

    cmp     r7, r29, 1
    bb1     eq, r7, bit_activo          ; Bit[r13] = 1 => Hay compresion

    st.b    r15, r11, r12               ; Zona3[r12] => descomprimido[r12]

    addu    r12, r12, 1
    addu    r13, r13, 1
    addu    r14, r14, 1

    br      bcle_prncp_desc

    bit_activo:                         ; Bit[r13] = 1 => Hay compresion

    ld.bu   r24, r4, r14                ; r24 = MSB
    addu    r14, r14, 1
    ld.bu   r25, r4, r14                ; r25 = LSB
    mulu    r25, r25, 256               ; r25 << 8
    addu    r24, r24, r25               ; r24 = (alto<<8) + bajo  = posicion referenciada
    addu    r14, r14, 1
    ld.bu   r25, r4, r14                ; r25 = longitud comprimida
    or      r26, r0, r0
    addu    r24, r11, r24                ; r24 = descomprimido + referenci
    
    bucle_descompresion:
    cmp     r7, r25, r26
    bb1     eq, r7, fin_descompresion
    ld.bu   r15, r24, r26               ; r15 = caracter refrenciado + r26
    st.b    r15, r11, r12               ; Guardamos caracter
    addu    r12, r12, 1                 ; Aumentamos indice *descomprimido
    addu    r26, r26, 1                 ; Aumentamos indice cadena referenciada
    br bucle_descompresion

    fin_descompresion:
    addu    r14, r14, 1
    addu    r13, r13, 1
    br bcle_prncp_desc

    fin_bucle_desc:
    st.b   r0, r11, r12
    or      r29, r12, r0

    jmp (r1)
    

LeeBit:
    ; Guardar r1 y r31
    PUSH    (r1)                                    
    PUSH    (r31)                                   
    or      r31, r30, r0                             ; Marco de pila

    ; Cargar parámetros
    ld      r10, r31, 8                              ; r10 = dirZonaCB
    ld      r11, r31, 12                             ; r11 = NumBit
    or      r29,r0,0         

    ; byteOffset 
    divs     r12, r11, 8                            ; r12 = NumBit / 8      

    ; Obtener NumBit dentro del byte correspondiente
    or r18, r0, 8      ; Carga el valor 8 en r18

    mulu r18,r18,r12
    subu r13,r11,r18                                                                                                                
    or r14, r0, 7                                   ; r14 = 7
    subu r13, r14, r13                              ; r13 = 7 - r13 => posición de bit en el byte

    ; Preparar mascara
    or r3,r0,1                                      ;r3 = 1
    or r4,r0,2                                      ;r4 = 2

    addu r16, r10, r12                              ; r16 = dirZonaCB + byteOffset (Dir del byte)
    ld.bu r17, r16, r0                              ; r17 = contenido byte actual (lectura)
    cmp r7,r17,r0
    bb1 eq,r7,finLB


    ;Desplazar contenido byte a la dcha para dejar el bit x en posicion 0
    BucleLB1:
    cmp r7,r13,r0                                   ; Comprobamos si estamos en NumBit
    bb1 eq,r7,LB2                                   ; Si estamos => PBA1
    cmp r7,r17,r0
    bb1 eq,r7,LB2_0 
    divu r17,r17,r4                                 ; Desplazamos r17 un bit a la dcha
    subu r13,r13,1                                  ; Decrementamos contador de NumBit
    br BucleLB1

    LB2_0:
        or r29,r0,r0
        br finLB
    ;Aplicamos mascara
    LB2:
    and     r29,r17,r3                              ; Aplicamos mascara y guardamos en r29
    finLB:
    ; Restaurar pila y retornar
    POP(r31)
    POP(r1)
    jmp (r1)                                        ; Retorno

org 0xB000                                              ; dir donde se reserva campoBits
cadena: data "tres tristes tigres comen trigo en un trigal, el primer tigre que...\0"
comprimido: data ""
descomprimido: data ""
;
; Debe incorporar este fichero con TODAS sus l�neas, sin modificar
; ninguna de ellas, al final de su archivo CDV24.ens
;
; Este aviso se refiere tambi�n a las l�neas de comentario
; 
;
;; Grupo:    s.munoz-guerra - Fri Oct 24 18:41:19 CEST 2025

BuscaMax:
	PUSH (r1)
	PUSH (r31)
	or   r31, r30, 0
	or   r28, r0, 0x3107
	PUSH (r28)

	ld   r10, r31, 8;  REF
	ld   r11, r31, 12; MAX
	ld   r12, r31, 16; Dir(JJ)

	sub  r5, r0, 1		; guarda -1 en *JJ por si no se
	st   r5, r12, 0		; encuentran coincidencias

	addu r27, r0, r0  ; P
	addu r28, r0, r0  ; L

BucBM:
	ld.bu r20, r10, r11	; C=REF(max)

				; Reserva registros que
				; necesita conservar
	PUSH (r28) 	    	; L
	PUSH (r11)	    	; MAX

	     		    	; Par�metros de BuscaCar
	PUSH (r27)	    	; P
	PUSH (r10)	    	; REF
	PUSH (r20)	   	; C
	bsr  BuscaCar
	POP  (r20)
	POP  (r10)
	POP  (r27)

	POP  (r11)		; Recupera registros
	POP  (r28)	        ; salvaguardados

	cmp  r5, r29, r11	; nuevo P es >= MAX ??
	bb1  hs, r5, finBM
	addu r27, r29, r0	; P = nuevo P
	
	addu r13, r10, r27	; *REF(P)
	addu r14, r10, r11 	; *REF(max)	

	PUSH (r11)     		; Reserva registros que
	PUSH (r10)		; necesita conservar
	PUSH (r28)
	PUSH (r27)
	
	PUSH (r14)		; Par�metros de CoincidenCad
	PUSH (r13)
	bsr  CoincidenCad
	POP  (r13)
	POP  (r14)
	
	POP  (r27)		; Recupera registros
	POP  (r28)		; salvaguardados
	POP  (r10)
	POP  (r11)

	cmp r5, r29, r28	; Comprueba si longitud > L
	bb1 le, r5, contBM	; Si no lo es, contin�a
	cmp r5, r29, 255	; Comprueba si longitud > 255
	bb1 le, r5, noLimBM	; Si no lo es, contin�a
	addu r29, r0, 255	; Si lo es, limita su valor a 255
	
noLimBM:
	addu r28, r29, r0	; actualiza L
	ld   r12, r31, 16	; Dir(JJ)
	st   r27, r12, r0	; actualiza P en *JJ
	bb1 ge, r5, finBM	; Si coincidencia >= 255 termina
contBM: 
	addu r27, r27, 1	; Pasa al siguiente car�cter
	cmp  r5, r27, r11	; Es P>=max ?
	bb1  hs, r5, finBM
	
	br   BucBM   		; Nueva b�squeda del primer car�cter

finBM:
	addu r29, r28, r0	; asigna L al valor de retorno r29
	  
	or   r27, r0, 0x66E
	POP  (r28)

	or   r30, r31, 0
	POP  (r31)
	POP  (r1)
	jmp  (r1)
;; Grupo:    s.munoz-guerra
