; Autor: Samuel Muñoz-Guerra Gómez
; --------- MACROS ---------
LEA: MACRO(reg, ETIQ)
    or reg, r0, low(ETIQ)
    or.u reg, reg, high(ETIQ)
ENDMACRO

LOAD: MACRO(reg, ETIQ)
    LEA(reg, ETIQ)
    ld reg, r0, reg
ENDMACRO

PUSH: MACRO(ra)
    subu r30, r30, 4
    st ra, r30, 0
ENDMACRO

POP: MACRO(ra)
    ld ra, r30, 0
    addu r30, r30, 4
ENDMACRO

org 0x1000
ppal: 
    LEA(r30, 0xF000)                                ; Inicializar puntero de pila (r30 = 0xF000)

BancoPruebasComprime:
    LEA(r10,comprimido)
    PUSH(r10)
    LEA(r10,cadena)
    PUSH(r10)
    bsr Comprime

finPPAL:
    stop                                            ; Detener ejecución


PoneBitA1:                                          
    ; PoneBitA1(dirZonaCB, NumBit)
    ; r10 = dirZonaCB (dir del campo de bits)
    ; r11 = NumBit (numero bit a activar)
    ; r12 = byteOffset
    ; r18 = 8 × byteOffset (para calcular posicion bit dentro del byte)
    ; r13 = posición del bit dentro del byte (de 7 a 0)
    ; r14 = constante 7 
    ; r3  = mascara con el bit deseado activado
    ; r4  = constante 2 (para desplazar máscara)
    ; r7  = registro para comparaciones
    ; r16 = dir del byte a modificar (dirZonaCB + byteOffset)
    ; r17 = contenido del byte leido y despues actualizado

    PUSH    (r1)                                    
    PUSH    (r31)                                   
    or      r31, r30, r0                             ; Marco de pila

    ; Cargar parámetros
    ld      r10, r31, 8                              ; r10 = dirZonaCB
    ld      r11, r31, 12                             ; r11 = NumBit         

    ; byteOffset 
    divs     r12, r11, 8                            ; r12 = NumBit / 8      

    ; Obtener NumBit dentro del byte correspondiente
    or r18,r0,8
    mulu r18,r18,r12                                                        
    subu r13,r11,r18                                                        
    or r14, r0, 7                                   ; r14 = 7
    subu r13, r14, r13                              ; r13 = 7 - r13 => posición de bit en el byte

    ; Preparar mascara
    or r3,r0,1                                      ;r3 = 1
    or r4,r0,2                                      ;r4 = 2

    BuclePBA1:
    cmp r7,r13,r0                                   ; Comprobamos si estamos en NumBit
    bb1 eq,r7,PBA1                                  ; Si estamos => PBA1 
    muls r3,r4,r3                                   ; Desplazamos r3 un bit a la izqda
    subu r13,r13,1                                  ; Decrementamos contador de NumBit
    br BuclePBA1                                    
    
    ; Leer byte actual, modificarlo y almacenarlo
    PBA1:
    ld.bu r17, r10, r12                              ; r17 = contenido byte actual (lectura)

    or r17, r17, r3                                 ; r17 = byte actualizado  (poner el bit r11 a 1)
    st.b r17, r10, r12                                ; Escribir byte modificado en memoria

    ; Restaurar pila y retornar
    POP(r31)
    POP(r1)
    jmp (r1)                                        ; Retorno
BuscaCar:
    ; BuscaCar (C,ref,from, to)
    ; Registros usados:
    ; r3  = C (caracter a buscar)
    ; r4  = ref (direccion de la cadena)
    ; r5  = from (posicion inicial)
    ; r6  = to (posicion final o tope)
    ; r7  = registro de comparación
    ; r29  = puntero al índice actual
    ; r9  = Dir ref[from + i]
    ; r10 = caracteres que se van leyendo de la cadena
    ; r29 = valor de retorno (posición encontrada o to)

    PUSH(r1)
    PUSH(r31)

    or      r31, r30, r0           ; Marco de pila
    ld      r3, r31, 8        ; C <= carácter a buscar
    ld      r4, r31, 12       ; ref <= Dir de cadena
    ld      r5, r31, 16       ; from <= inicio
    ld      r6, r31, 20       ; to <= fin

    or      r29, r5, r0        ; índice actual = from

    bucle_BC:
    cmp     r7, r29, r6          ; ¿hemos llegado a to?
    bb1     eq, r7, fin_BC      ; Si hemos llegado => fin_BC
    ld.bu   r10, r4, r29          ; r10 <= carácter actual
    cmp     r7, r10, r3         ; ¿carácter actual == C?
    bb1     eq, r7, fin_BC
    addu    r29, r29, 1           ; avanzar índice
    br      bucle_BC

    fin_BC:
    POP(r31)
    POP(r1)
    jmp(r1)
LongCad:
    ; LongCad (cadena)
    ; r10 = *cadena (dir de inicio)
    ; r3  = caracteres que se van leyendo de la cadena
    ; r7  = comparación con 0 (detecta fin de cadena)
    ; r29 = contador de longitud (valor de retorno)
    
    PUSH    (r1)                    
    PUSH    (r31)
    or      r31,r30,r0                  ; Marco de pila
    ld      r10,r31,8                   ; Cargar dir de la cadena
    or      r29, r0, r0                 ; Inicializar contador en 0

    bucle_longcad:
    ld.bu   r3, r10, 0                  ; Cargar byte (carácter)
    cmp     r7, r3, r0
    bb1     eq, r7, fin_longcad         ; Si es 0, fin de cadena
    addu    r29, r29, 1                 ; Incrementar contador
    addu    r10, r10, 1                 ; Avanzar al siguiente carácter
    br      bucle_longcad               ; Repetir

    fin_longcad:
    or      r30,r31,0
    POP     (r31)
    POP     (r1)                        ; Restaurar dir de retorno
    jmp     (r1)                        ; Volver a la rutina llamante
CoincidenCad:
    ; CoincidenCad(cadena1, cadena2)
    ; r10 = *cadena1 (dir de inicio)
    ; r11 = *cadena2 (dir de inicio)
    ; r3  = caracteres que se van cargando de cadena1
    ; r4  = caracteres que se van cargando de cadena2
    ; r7  = Comparaciones (fin cadenas o !(coinciden caracteres))
    ; r29 = contador de carcateres coincidentes (valor de retorno)
    
    PUSH    (r1)
    PUSH    (r31)

    or      r31, r30, r0                ; Marco de pila
    ld      r10, r31, 8                 ; Cargamos cadena1
    ld      r11, r31, 12                ; Cargamos cadena2
    or      r29, r0, r0                 ; Inicializamos contador

    bucle_CC:
    ld.bu   r3, r10, 0                  ; Cargamos byte de cadena 1(Car1)
    ld.bu   r4, r11, 0                  ; Cargamos byte de cadena 2(Car1)
    cmp     r5, r3, r0                  ; Comprobamos si final cadena 1
    bb1     eq, r5, fin_CC              ; Si Car1 = null => fin_CC
    cmp     r6, r4, r0                  ; Comprobamos si final cadena 2
    bb1     eq, r6, fin_CC              ; Si Car2 = null => fin_CC
    cmp     r7, r3, r4                  ; Comprobamos Car1 = Car2
    bb1     ne, r7, fin_CC              ; Si Car1 != Car2 => fin_CC
    addu    r29, r29, 1                 ; Si todo correcto aumentamos en 1 el contador
    addu    r10, r10, 1                 ; *r10 = siguiente carácter de cadena 1
    addu    r11, r11, 1                 ; *r11 = siguiente carácter de cadena 2
    br      bucle_CC

    fin_CC:
    POP     (r31)
    POP     (r1)
    jmp     (r1)

Verifica:
    jmp (r1)
Comprime:
    ; ==============================================================================
    ; SUBRUTINA: Comprime
    ; ==============================================================================
    ; INPUT:
    ;   [r31+8]  : Dir Texto Original
    ;   [r31+12] : Dir Texto Comprimido
    ;
    ; OUTPUT:
    ;   r29       : Longitud total en bytes del resultado comprimido.
    ; ------------------------------------------------------------------------------
    ; TABLA DE REGISTROS (Contexto de la Rutina):
    ; ------------------------------------------------------------------------------
    ; CONSTANTES:
    ;   r8  = M * 8 (8)     -> Longitud prefijo no comprimible
    ;   r9  = N (4)         -> Longitud mínima para comprimir
    ;
    ; PUNTEROS:
    ;   r10 = Puntero Lectura Texto Original
    ;   r11 = Puntero Escritura Cabecera (Inicio Salida)
    ;   r12 = Puntero Escritura MapaBits
    ;   r16 = Puntero Escritura Zona3 (Pila Temporal)
    ;
    ; ÍNDICES Y CONTADORES:
    ;   r3  = Longitud Total Texto Original
    ;   r13 = Índice Actual en Texto Original (i)
    ;   r14 = Índice Actual en Zona3 (j)
    ;   r15 = Índice de Bit Global (k)
    ;   r21 = Tamaño en Bytes del MapaBits
    ;
    ; TEMPORALES:
    ;   r29 = Retorno de subrutinas (Longitud encontrada, etc.)
    ;   r28 = Posición previa (P) devuelta por BuscaMax
    ; ==============================================================================

    ; --------------------------------------------------------------------------
    ; 1. PRÓLOGO: Crear marco de pila y salvar registros del llamante
    ; --------------------------------------------------------------------------
    PUSH    (r1)                ; Dir de retorno
    PUSH    (r31)               ; Marco anterior
    or      r31, r30, r0        ; Nuevo marco (FP)

    ; --------------------------------------------------------------------------
    ; 2. CÁLCULO DE LONGITUD ORIGINAL
    ; --------------------------------------------------------------------------
    ld      r10, r31, 8         ; Cargar argumento: Dir Texto Original
    
    PUSH    (r10)               ; Arg1: Texto
    bsr     LongCad             ; -> devuelve r29 = longitud
    POP     (r10)               ; Limpiar pila args

    or      r3, r29, r0         ; r3 = Longitud Texto Original

    ; --------------------------------------------------------------------------
    ; 3. INICIALIZACIÓN DE CABECERA Y VARIABLES
    ; --------------------------------------------------------------------------
    ld      r11, r31, 12        ; Cargar argumento: Dir Salida
    st.h    r3,  r11, 0         ; Byte 0-1: Longitud Original
    
    or      r8,  r0, 1          ; M = 1
    st.b    r8,  r11, 2         ; Byte 2: M
    mulu    r8,  r8, 8          ; r8 = 8 (caracteres inalterables)
    or      r9,  r0, 4          ; r9 = 4 (N, umbral compresión)

    ; Calcular parámetros del Mapa de Bits
    addu    r12, r11, 5         ; r12 = Inicio datos MapaBits (Offset 5)
    
    subu    r20, r3, r8         ; r20 = (Longitud - 8) -> Bits necesarios
    subu    r20, r20, 4
    addu    r21, r20, 7         ; r21 = (Bits + 7) ...
    divu    r21, r21, 8         ; r21 = ... / 8 -> Bytes para MapaBits       
    
    ; --------------------------------------------------------------------------
    ; 4. LIMPIEZA DEL MAPA DE BITS (Poner a 0)
    ; --------------------------------------------------------------------------
    or      r24, r0, r0         ; Reinicializar Contador i = 0         ; i = 0
init_mapa:
    cmp     r7, r24, r21        ; while (i < TamMapaBits)
    bb1     ge, r7, fin_init_mapa
    st.b    r0, r12, r24        ; Mapa[i] = 0
    addu    r24, r24, 1         ; i++
    br      init_mapa
fin_init_mapa:
    or      r4,r0,r0            ;Contador Tamño MapaBits
    ; --------------------------------------------------------------------------
    ; 5. RESERVA DE MEMORIA TEMPORAL (Zona3) EN PILA (Alineada a 4 bytes)
    ; --------------------------------------------------------------------------
    or      r22, r3, r0         ; Tamaño base = Longitud Texto
    and     r23, r22, 3         ; Resto división entre 4
    cmp     r7, r23, r0
    bb1     eq, r7, zona3_ok
    subu    r22, r22, r23       ; Alinear...
    addu    r22, r22, 4         
zona3_ok:
    subu    r30, r30, r22       ; SP = SP - Tamaño
    or      r16, r30, r0        ; r16 = Puntero Base Zona3

    ; --------------------------------------------------------------------------
    ; 6. COPIA INICIAL (Primeros 8 caracteres directos)
    ; --------------------------------------------------------------------------
    or      r13, r0, r0         ; Índice Texto = 0
    or      r14, r0, r0         ; Índice Zona3 = 0
    or      r15, r0, r0         ; Índice Bit   = 0

bucle_copia:
    cmp     r7, r13, r8         ; while (i < 8)
    bb1     ge, r7, bucle_principal
    ld.bu    r25, r10, r13       ; Leer de Original
    st.b    r25, r16, r14       ; Escribir en Zona3
    addu    r13, r13, 1         ; i++
    addu    r14, r14, 1         ; j++
    br      bucle_copia

    ; ==========================================================================
    ; 7. BUCLE PRINCIPAL DE COMPRESIÓN
    ; ==========================================================================
bucle_principal:
    cmp     r7, r13, r3         ; while (i < LongitudOriginal)
    bb1     ge, r7, fin_bucle

    ; ----------------------------------------------------------------------
    ; SALVAGUARDA DE REGISTROS (Contexto antes de llamar a subrutina)
    ; ----------------------------------------------------------------------
    ; Guardamos TODOS los registros vivos que usamos en el bucle
    
    PUSH(r3)                    ; Longitud Total
    PUSH(r4)
    PUSH(r9)
    PUSH(r12)
    PUSH(r13)
    PUSH(r14)
    PUSH(r15)

    ; ----------------------------------------------------------------------
    ; PREPARAR Y LLAMAR A BuscaMax
    ; ----------------------------------------------------------------------
    subu    r30, r30, 4         ; Espacio para variable local 'jj' (salida)
    or      r26, r30, r0        ; r26 = &jj

    PUSH(r26)                   ; Arg3: Puntero a variable donde dejar P
    PUSH(r13)                   ; Arg2: Posición actual (MAX)
    PUSH(r10)                   ; Arg1: Dir inicio Texto
    
    bsr     BuscaMax            ; -> Retorna L en r29, P en [r26]
    
    POP(r10)                    ; Limpiar Args...
    POP(r13)
    POP(r26)

    ld      r28, r26, 0         ; Recuperar P de la variable local 'jj'
    addu    r30, r30, 4         ; Liberar variable local 'jj'

    ; ----------------------------------------------------------------------
    ; RESTAURAR REGISTROS
    ; ----------------------------------------------------------------------
    ; IMPORTANTE: En orden inverso al PUSH
    POP(r15)
    POP(r14)
    POP(r13)
    POP(r12)
    POP(r9)
    POP(r4)
    POP(r3)
    
decision:
    ; ----------------------------------------------------------------------
    ; DECISIÓN: ¿COMPRIMIR O COPIAR? ( L >= N )
    ; ----------------------------------------------------------------------
    cmp     r7, r29, r9         
    bb1     lt, r7, no_comprime ; Si (L < 4) -> No comprimir
    addu    r4, r4, r29           ;Contador caracteres Mapa Bits ++

    ; >>> CASO: SÍ COMPRIMIR (Bit = 1) <<<
    PUSH(r3)
    PUSH(r4)
    PUSH(r10)
    PUSH(r13)
    PUSH(r14)
    ; Marcar Bit 1 en MapaBits
    PUSH(r15)                   ; Arg2: NumBit
    PUSH(r12)                   ; Arg1: DirZonaCB
    bsr     PoneBitA1           ; Llamada
    POP(r12)                    ; Limpiar Args
    POP(r15)

    POP(r14)
    POP(r13)
    POP(r10)
    POP(r4)
    POP(r3)
    ; Guardar Referencia (P, L) en Zona3
    ; 1. Escribir Byte Bajo (LSB) en offset 3
DespPBA1:st.b    r28, r16, r14
    
    ; 2. Calcular y Escribir Byte Alto (MSB) en offset 4
    or      r24, r0, 256        ; Usamos r24 como divisor temporal
    divu    r24, r28, r24        ; r24 = r28 / 256 (Desplazamiento >> 8)
    addu    r23, r14, 1
    st.b    r24, r16, r23

    addu    r14, r14, 2         ; j += 2
    st.b    r29, r16, r14       ; Guardar L (1 byte)
    addu    r14, r14, 1         ; j += 1

    ; Actualizar Índices
    addu    r13, r13, r29       ; i += L (Avanzamos L caracteres)
    addu    r15, r15, 1         ; k++    (Siguiente bit)
    
    br      bucle_principal

no_comprime:
    ; >>> CASO: NO COMPRIMIR (Copiar literal) <<<
    
    ld.bu    r25, r10, r13       ; Cargar char original
    st.b    r25, r16, r14       ; Guardar en Zona3
    
    addu    r13, r13, 1         ; i++
    addu    r14, r14, 1         ; j++
    addu    r15, r15, 1         ; k++
    
    br      bucle_principal

fin_bucle:
    ; --------------------------------------------------------------------------
    ; 8. CONSTRUCCIÓN DEL RESULTADO FINAL
    ; --------------------------------------------------------------------------
    ; En este punto tenemos:
    ; - Cabecera casi escrita (falta Tamño MapaBits) en [r11]
    ; - MapaBits escrito en [r12 ... r12+r21]
    ; - Comprimidos escritos en Zona3 [r16 ... r16+r14] (memoria temporal en pila)
    
    ; --------------------------------------------------------------------------
    ; Guardar Tamño de MapaBits en cabecera y calcular dir zona3
    ; --------------------------------------------------------------------------
    ; 1. Escribir Byte Bajo (LSB) en offset 3
    ld      r11, r31, 12
    addu    r15, r15, 7
    divu    r15, r15, 8
    addu    r15, r15, 5
    st.b    r15, r11, 3
    
    ; 2. Calcular y Escribir Byte Alto (MSB) en offset 4
    or      r24, r0, 256        ; Usamos r24 como divisor temporal
    divu    r24, r15, r24        ; r24 = r4 / 256 (Desplazamiento >> 8)
    st.b    r24, r11, 4
    
    ; Necesitamos mover Zona3 a continuación del MapaBits para que quede todo contiguo.
    ; Destino = FinMapaBits = r12 + r21
    addu    r25, r11, r15        ; Dir Destino para Zona3
    or      r24, r0, r0         ; Contador = 0

copiar_zona3:
    cmp     r7, r24, r14        ; while (contador < longitud_zona3)
    bb1     ge, r7, fin_zona3
    
    ld.bu    r27, r16, r24       ; Leer byte de Zona3 (Pila)
    st.b    r27, r25, r24       ; Escribir a continuación del mapa
    
    addu    r24, r24, 1
    br      copiar_zona3
fin_zona3:

    ; --------------------------------------------------------------------------
    ; 9. CÁLCULO DE RESULTADO Y EPÍLOGO
    ; --------------------------------------------------------------------------

    ; Liberar pila (Zona3)
    or      r30, r31, r0        ; Restaurar SP al marco original (libera todo lo allocado)
    
    POP     (r31)               ; Restaurar Frame Pointer anterio
    POP     (r1)                ; Restaurar Retorno
    jmp     (r1)                ; Volver a casa
Descomprime:
    jmp (r1)
LeeBit:
    ; Guardar r1 y r31
    PUSH    (r1)                                    
    PUSH    (r31)                                   
    or      r31, r30, r0                             ; Marco de pila

    ; Cargar parámetros
    ld      r10, r31, 8                              ; r10 = dirZonaCB
    ld      r11, r31, 12                             ; r11 = NumBit
    or      r29,r0,0         

    ; byteOffset 
    divs     r12, r11, 8                            ; r12 = NumBit / 8      

    ; Obtener NumBit dentro del byte correspondiente
    or r18, r0, 8      ; Carga el valor 8 en r18

    mulu r18,r18,r12
    subu r13,r11,r18                                                                                                                
    or r14, r0, 7                                   ; r14 = 7
    subu r13, r14, r13                              ; r13 = 7 - r13 => posición de bit en el byte

    ; Preparar mascara
    or r3,r0,1                                      ;r3 = 1
    or r4,r0,2                                      ;r4 = 2

    addu r16, r10, r12                              ; r16 = dirZonaCB + byteOffset (Dir del byte)
    ld.bu r17, r16, r0                              ; r17 = contenido byte actual (lectura)
    cmp r7,r17,r0
    bb1 eq,r7,finLB


    ;Desplazar contenido byte a la dcha para dejar el bit x en posicion 0
    BucleLB1:
    cmp r7,r13,r0                                   ; Comprobamos si estamos en NumBit
    bb1 eq,r7,LB2                                   ; Si estamos => PBA1
    cmp r7,r17,r0
    bb1 eq,r7,LB2_0 
    divu r17,r17,r4                                 ; Desplazamos r17 un bit a la dcha
    subu r13,r13,1                                  ; Decrementamos contador de NumBit
    br BucleLB1

    LB2_0:
        or r29,r0,r0
        br finLB
    ;Aplicamos mascara
    LB2:
    and     r29,r17,r3                              ; Aplicamos mascara y guardamos en r29
    finLB:
    ; Restaurar pila y retornar
    POP(r31)
    POP(r1)
    jmp (r1)                                        ; Retorno

;
; Debe incorporar este fichero con TODAS sus l�neas, sin modificar
; ninguna de ellas, al final de su archivo CDV24.ens
;
; Este aviso se refiere tambi�n a las l�neas de comentario
; 
;
;; Grupo:    s.munoz-guerra - Fri Oct 24 18:41:19 CEST 2025

BuscaMax:
	PUSH (r1)
	PUSH (r31)
	or   r31, r30, 0
	or   r28, r0, 0x3107
	PUSH (r28)

	ld   r10, r31, 8;  REF
	ld   r11, r31, 12; MAX
	ld   r12, r31, 16; Dir(JJ)

	sub  r5, r0, 1		; guarda -1 en *JJ por si no se
	st   r5, r12, 0		; encuentran coincidencias

	addu r27, r0, r0  ; P
	addu r28, r0, r0  ; L

BucBM:
	ld.bu r20, r10, r11	; C=REF(max)

				; Reserva registros que
				; necesita conservar
	PUSH (r28) 	    	; L
	PUSH (r11)	    	; MAX

	     		    	; Par�metros de BuscaCar
	PUSH (r27)	    	; P
	PUSH (r10)	    	; REF
	PUSH (r20)	   	; C
	bsr  BuscaCar
	POP  (r20)
	POP  (r10)
	POP  (r27)

	POP  (r11)		; Recupera registros
	POP  (r28)	        ; salvaguardados

	cmp  r5, r29, r11	; nuevo P es >= MAX ??
	bb1  hs, r5, finBM
	addu r27, r29, r0	; P = nuevo P
	
	addu r13, r10, r27	; *REF(P)
	addu r14, r10, r11 	; *REF(max)	

	PUSH (r11)     		; Reserva registros que
	PUSH (r10)		; necesita conservar
	PUSH (r28)
	PUSH (r27)
	
	PUSH (r14)		; Par�metros de CoincidenCad
	PUSH (r13)
	bsr  CoincidenCad
	POP  (r13)
	POP  (r14)
	
	POP  (r27)		; Recupera registros
	POP  (r28)		; salvaguardados
	POP  (r10)
	POP  (r11)

	cmp r5, r29, r28	; Comprueba si longitud > L
	bb1 le, r5, contBM	; Si no lo es, contin�a
	cmp r5, r29, 255	; Comprueba si longitud > 255
	bb1 le, r5, noLimBM	; Si no lo es, contin�a
	addu r29, r0, 255	; Si lo es, limita su valor a 255
	
noLimBM:
	addu r28, r29, r0	; actualiza L
	ld   r12, r31, 16	; Dir(JJ)
	st   r27, r12, r0	; actualiza P en *JJ
	bb1 ge, r5, finBM	; Si coincidencia >= 255 termina
contBM: 
	addu r27, r27, 1	; Pasa al siguiente car�cter
	cmp  r5, r27, r11	; Es P>=max ?
	bb1  hs, r5, finBM
	
	br   BucBM   		; Nueva b�squeda del primer car�cter

finBM:
	addu r29, r28, r0	; asigna L al valor de retorno r29
	  
	or   r27, r0, 0x66E
	POP  (r28)

	or   r30, r31, 0
	POP  (r31)
	POP  (r1)
	jmp  (r1)
;; Grupo:    s.munoz-guerra

org 0xB000                                              ; dir donde se reserva campoBits
cadena: data "tres tristes tigres comen trigo en un trigal, el primer tigre que...\0"
comprimido: data ""