; Autor: Samuel Muñoz-Guerra Gómez
; --------- MACROS ---------
LEA: MACRO(reg, ETIQ)
    or reg, r0, low(ETIQ)
    or.u reg, reg, high(ETIQ)
ENDMACRO

LOAD: MACRO(reg, ETIQ)
    LEA(reg, ETIQ)
    ld reg, r0, reg
ENDMACRO

PUSH: MACRO(ra)
    subu r30, r30, 4
    st ra, r30, 0
ENDMACRO

POP: MACRO(ra)
    ld ra, r30, 0
    addu r30, r30, 4
ENDMACRO

org 0x1000
ppal: 
    LEA(r30, 0xF000)                                ; Inicializar puntero de pila (r30 = 0xF000)

BancoPruebasComprime:
    LEA(r10,comprimido)
    PUSH(r10)
    LEA(r10,cadena)
    PUSH(r10)
    bsr Comprime

finPPAL:
    stop                                            ; Detener ejecución


PoneBitA1:                                          
    ; PoneBitA1(dirZonaCB, NumBit)
    ; r10 = dirZonaCB (dir del campo de bits)
    ; r11 = NumBit (numero bit a activar)
    ; r12 = byteOffset
    ; r18 = 8 × byteOffset (para calcular posicion bit dentro del byte)
    ; r13 = posición del bit dentro del byte (de 7 a 0)
    ; r14 = constante 7 
    ; r3  = mascara con el bit deseado activado
    ; r4  = constante 2 (para desplazar máscara)
    ; r7  = registro para comparaciones
    ; r16 = dir del byte a modificar (dirZonaCB + byteOffset)
    ; r17 = contenido del byte leido y despues actualizado

    PUSH    (r1)                                    
    PUSH    (r31)                                   
    or      r31, r30, r0                             ; Marco de pila

    ; Cargar parámetros
    ld      r10, r31, 8                              ; r10 = dirZonaCB
    ld      r11, r31, 12                             ; r11 = NumBit         

    ; byteOffset 
    divs     r12, r11, 8                            ; r12 = NumBit / 8      

    ; Obtener NumBit dentro del byte correspondiente
    or r18,r0,8
    mulu r18,r18,r12                                                        
    subu r13,r11,r18                                                        
    or r14, r0, 7                                   ; r14 = 7
    subu r13, r14, r13                              ; r13 = 7 - r13 => posición de bit en el byte

    ; Preparar mascara
    or r3,r0,1                                      ;r3 = 1
    or r4,r0,2                                      ;r4 = 2

    BuclePBA1:
    cmp r7,r13,r0                                   ; Comprobamos si estamos en NumBit
    bb1 eq,r7,PBA1                                  ; Si estamos => PBA1 
    muls r3,r4,r3                                   ; Desplazamos r3 un bit a la izqda
    subu r13,r13,1                                  ; Decrementamos contador de NumBit
    br BuclePBA1                                    
    
    ; Leer byte actual, modificarlo y almacenarlo
    PBA1:
    ld.b r17, r10, r12                              ; r17 = contenido byte actual (lectura)

    or r17, r17, r3                                 ; r17 = byte actualizado  (poner el bit r11 a 1)
    st.b r17, r10, r12                                ; Escribir byte modificado en memoria

    ; Restaurar pila y retornar
    POP(r31)
    POP(r1)
    jmp (r1)                                        ; Retorno
BuscaCar:
    ; BuscaCar (C,ref,from, to)
    ; Registros usados:
    ; r3  = C (caracter a buscar)
    ; r4  = ref (direccion de la cadena)
    ; r5  = from (posicion inicial)
    ; r6  = to (posicion final o tope)
    ; r7  = registro de comparación
    ; r29  = puntero al índice actual
    ; r9  = dirección ref[from + i]
    ; r10 = caracteres que se van leyendo de la cadena
    ; r29 = valor de retorno (posición encontrada o to)

    PUSH(r1)
    PUSH(r31)

    or      r31, r30, r0           ; Marco de pila
    ld      r3, r31, 8        ; C <= carácter a buscar
    ld      r4, r31, 12       ; ref <= dirección de cadena
    ld      r5, r31, 16       ; from <= inicio
    ld      r6, r31, 20       ; to <= fin

    or      r29, r5, r0        ; índice actual = from

    bucle_BC:
    cmp     r7, r29, r6          ; ¿hemos llegado a to?
    bb1     eq, r7, fin_BC      ; Si hemos llegado => fin_BC
    ld.bu   r10, r4, r29          ; r10 <= carácter actual
    cmp     r7, r10, r3         ; ¿carácter actual == C?
    bb1     eq, r7, fin_BC
    addu    r29, r29, 1           ; avanzar índice
    br      bucle_BC

    fin_BC:
    POP(r31)
    POP(r1)
    jmp(r1)
LongCad:
    ; LongCad (cadena)
    ; r10 = *cadena (dir de inicio)
    ; r3  = caracteres que se van leyendo de la cadena
    ; r7  = comparación con 0 (detecta fin de cadena)
    ; r29 = contador de longitud (valor de retorno)
    
    PUSH    (r1)                    
    PUSH    (r31)
    or      r31,r30,r0                  ; Marco de pila
    ld      r10,r31,8                   ; Cargar dir de la cadena
    or      r29, r0, r0                 ; Inicializar contador en 0

    bucle_longcad:
    ld.bu   r3, r10, 0                  ; Cargar byte (carácter)
    cmp     r7, r3, r0
    bb1     eq, r7, fin_longcad         ; Si es 0, fin de cadena
    addu    r29, r29, 1                 ; Incrementar contador
    addu    r10, r10, 1                 ; Avanzar al siguiente carácter
    br      bucle_longcad               ; Repetir

    fin_longcad:
    or      r30,r31,0
    POP     (r31)
    POP     (r1)                        ; Restaurar dir de retorno
    jmp     (r1)                        ; Volver a la rutina llamante
CoincidenCad:
    ; CoincidenCad(cadena1, cadena2)
    ; r10 = *cadena1 (dir de inicio)
    ; r11 = *cadena2 (dir de inicio)
    ; r3  = caracteres que se van cargando de cadena1
    ; r4  = caracteres que se van cargando de cadena2
    ; r7  = Comparaciones (fin cadenas o !(coinciden caracteres))
    ; r29 = contador de carcateres coincidentes (valor de retorno)
    
    PUSH    (r1)
    PUSH    (r31)

    or      r31, r30, r0                ; Marco de pila
    ld      r10, r31, 8                 ; Cargamos cadena1
    ld      r11, r31, 12                ; Cargamos cadena2
    or      r29, r0, r0                 ; Inicializamos contador

    bucle_CC:
    ld.bu   r3, r10, 0                  ; Cargamos byte de cadena 1(Car1)
    ld.bu   r4, r11, 0                  ; Cargamos byte de cadena 2(Car1)
    cmp     r5, r3, r0                  ; Comprobamos si final cadena 1
    bb1     eq, r5, fin_CC              ; Si Car1 = null => fin_CC
    cmp     r6, r4, r0                  ; Comprobamos si final cadena 2
    bb1     eq, r6, fin_CC              ; Si Car2 = null => fin_CC
    cmp     r7, r3, r4                  ; Comprobamos Car1 = Car2
    bb1     ne, r7, fin_CC              ; Si Car1 != Car2 => fin_CC
    addu    r29, r29, 1                 ; Si todo correcto aumentamos en 1 el contador
    addu    r10, r10, 1                 ; *r10 = siguiente carácter de cadena 1
    addu    r11, r11, 1                 ; *r11 = siguiente carácter de cadena 2
    br      bucle_CC

    fin_CC:
    POP     (r31)
    POP     (r1)
    jmp     (r1)

Verifica:
    jmp (r1)
Comprime:
    ; ============================================================
    ; SUBRUTINA: Comprime
    ; ------------------------------------------------------------
    ; Objetivo:
    ;   Comprime el texto original (parámetro 1) y deja el
    ;   resultado en la zona indicada (parámetro 2).
    ;   Devuelve en r2 la longitud total del texto comprimido.
    ;
    ; ------------------------------------------------------------
    ; REGISTROS UTILIZADOS:
    ; ------------------------------------------------------------
    ; r3   = Longitud original
    ; r2   = Longitud total del texto comprimido (resultado final)
    ; r8   = Constante M (número de caracteres sin comprimir: 8)
    ; r9   = Constante N (longitud mínima para comprimir: 4)
    ; r10  = Dirección del texto original
    ; r11  = Dirección del texto comprimido (salida)
    ; r12  = Dirección del mapa de bits (comprdo + 5)
    ; r13  = Índice en el texto original
    ; r14  = Índice en pilaZona3 (temporal en pila)
    ; r15  = Número de bit en el mapa de bits
    ; r16  = Dirección de pilaZona3 (reservada en pila)
    ; r20  = LongitudTexto - M*8 (para mapa de bits)
    ; r21  = Número de bytes del mapa de bits
    ; r22  = Tamaño reservado para pilaZona3 (ajustado a múltiplo de 4)
    ; r23  = Resto para alineación
    ; r24  = Auxiliar para comparaciones
    ; r25  = Carácter temporal para copia
    ; r29  = Valor devuelto por subrutinas (LongCad, BuscaMax...)
    ; ------------------------------------------------------------
    ; PILA:
    ;   [r31+8]  = Dirección del texto original
    ;   [r31+12] = Dirección del texto comprimido
    ; ============================================================

    ; --- Salvaguarda del contexto ---
    PUSH    (r1)                  ; Guarda dirección de retorno
    PUSH    (r31)                 ; Guarda marco de pila anterior
    or      r31, r30, r0        ; Activa nuevo marco de pila

    ; --- Calcular longitud del texto original ---
    ld      r10, r31, 8         ; r10 = dirección del texto original
    PUSH    (r10)                 ; Prepara parámetro para LongCad
    bsr     LongCad             ; Llama a LongCad → devuelve longitud en r29
    POP     (r10)                  ; Recupera r10 (dirección del texto)
    
    
    ; --- Inicialización de variables ---
    ld      r11, r31, 12        ; r11 = dirección del texto comprimido
    st.h    r29, r11, 0         ; Guardamos longitud texto original
    or      r8,  r0, 1          ; r8 = M 
    st      r8, r11, 2          ; Guardamos el valor de M en el tercer byte
    mulu    r8, r8, 8           ; r8 = M*8 (número de caracteres sin comprimir: 8)
    or      r9,  r0, 4          ; r9 = N (longitud mínima para comprimir: 4)
    or      r3, r29,r0          ; r3 = longitud original

    ; --- Calcular dirección del mapa de bits ---
    addu  r12, r11, 5         ; r12 = dirección del mapa de bits (después de cabecera de 5 bytes)

    ; --- Calcular tamaño del mapa de bits ---
    subu  r20, r29, r8        ; r20 = longitudTexto - M*8
    addu  r21, r20, 7         ; r21 = longitudTexto - M*8 + 7 (para redondear)
    divu  r21, r21, 8         ; r21 = número de bytes del mapa de bits
    addu  r4, r21, 5          ; Desplazamiento desde v.salida hasta cadena comprimida
    st.d  r4, r11, 3          ; Guardamos en los bytes 4 y 5 el desplazamiento
    ; Cabecera =    Byte 1 y 2     | Byte 3 | Byte 4 y 5
    ;            Tam cad original  |   M    | Desp desde v.salida a txto cmprmdo

    ; --- Reservar espacio para pilaZona3 en la pila ---
    or    r22, r29, r0        ; r22 = longitudTexto (caso peor: sin compresión)
    and  r23, r22, 3         ; r23 = cargamos un 3 para alineación
    cmp   r7, r23, r0        ; si en r23 hay un 0 es que r22 es multiplo de 4
    bb1   eq, r7, zona3_ok    ; Si ya está alineado, saltar
    subu  r22, r22, r23       ; Ajustar hacia abajo
    addu  r22, r22, 4         ; Sumar al múltiplo anterior 4 para estar alineados y con suficiente espacio
zona3_ok:
    subu  r30, r30, r22       ; Reserva espacio en la pila
    or    r16, r30, r0        ; r16 = dirección de pilaZona3 (temporal)

    ; --- Inicializar marcadores ---
    or    r13, r0, r0         ; r13 = índice en texto original
    or    r14, r0, r0         ; r14 = índice en pilaZona3
    or    r15, r0, r0         ; r15 = número de bit en mapa de bits

    ;Registros importantes ahora
    ; r3 = longitud texto original
    ; r10 = dir texto original
    ; r11 = dir texto comprimido
    ; r12 = dir mapa bits
    ; r13 = índice en texto original
    ; r14 = índice en pilaZona3
    ; r15 = número de bit en mapa de bits
    ; r16 = dir zona3

    ; --- Copiar los primeros M*8 caracteres sin comprimir ---
bucle_copia:
    cmp   r7, r13, r8           ; ¿hemos copiado 8 caracteres?
    bb1   ge, r7, fin_copia     ; Si sí, salir del bucle
    ld.b  r25, r10, r13         ; r25 = carácter del texto original
    st.b  r25, r16, r14         ; Guardar carácter en pilaZona3
    addu  r13, r13, 1           ; Avanzar índice texto
    addu  r14, r14, 1           ; Avanzar índice pilaZona3
    br    bucle_copia
fin_copia:
    ;ANTES DE ENTRARA AL BUCLE HACEMOS PUSH
    PUSH(r3)
    PUSH(r10)
    PUSH(r11)
    PUSH(r12)
    PUSH(r13)
    PUSH(r14)
    PUSH(r15)
    PUSH(r16)
    PUSH(r21)


; Bucle principal:
; - Recorre el texto desde la posición M*8 hasta el final.
; - Para cada posición:
;   1. Llama a BuscaMax para encontrar la subcadena repetida más larga.
;   2. Si la longitud encontrada (L) < N:
;        - Copia el carácter actual a zona3.
;        - Avanza índices (texto, zona3, mapa de bits).
;   3. Si L >= N:
;        - Marca el bit correspondiente en el mapa de bits (PoneBitA1).
;        - Guarda en zona3 la referencia (posición previa P y longitud L).
;        - Avanza índices (texto salta L, zona3 suma 3 bytes, mapa de bits +1).
; - Repite hasta procesar todos los caracteres del texto.

bucle_principal:
    cmp   r7, r13, r3          ; ¿hemos llegado al final del texto?
    bb1   ge, r7, fin_bucle     ; Si r13 >= longitudTexto, salir

    ; --- Guardar registros importantes antes de llamar a BuscaMax ---
    PUSH(r24)
    PUSH(r13)                    ; Dirección del texto original
    PUSH(r14)
    PUSH(r15)
    PUSH(r16)
    PUSH(r3)                     ; Índice en texto
    PUSH(r27)                    ; Índice en zona3
    PUSH(r28)                    ; Número de bit en mapa de bits
    PUSH(r24)                    ; Dirección de zona3
    PUSH(r9)                     ; Dirección del mapa de bits
    PUSH(r3)

    ; --- Preparar parámetros para BuscaMax ---
    subu  r30, r30, 4            ; Reserva espacio para jj
    or    r26, r30, r0           ; r26 = dirección local para jj
    PUSH(r26)                    ; jj = dirección donde se guardará P
    PUSH(r13)                    ; max = posición actual
    PUSH(r10)                    ; ref = dirección del texto original
    bsr   BuscaMax               ; Llamada a la subrutina
    POP(r10)                     ; Recupera dir texto original
    POP(r13)                     ; Recupera posición actual
    POP(r26)                     ; Recupera *jj

    ; --- Recuperar registros importantes ---
    POP(r3)
    POP(r9)
    POP(r16)
    POP(r15)
    POP(r14)
    POP(r13)
    POP(r10)
    POP(r9)
    ; --- Procesar resultados de BuscaMax ---
resulBM:ld    r28, r26, 0            ; r28 = P (posición previa)

    ; --- Comprobar si L >= N ---
    cmp   r7, r29, r9
    bb1   lt, r7, no_comprime   ; Si L < N, copiar carácter

    ; --- Comprimir por referencia ---
    ; Guardar registros antes de llamar a PoneBitA1
    PUSH(r12)
    PUSH(r15)
    PUSH(r1)
    bsr   PoneBitA1              ; Marca el bit correspondiente
    POP(r1)
    POP(r15)
    POP(r12)

    ; Guardar P (2 bytes) y L (1 byte) en zona3
    st.h  r28, r16, r14          ; desplazamienot P
    addu  r14, r14, 2
    st.b  r29, r16, r14          ; longitud L
    addu  r14, r14, 1

    ; Avanzar índices
    addu  r13, r13, r29          ; saltar L caracteres en texto
    addu  r15, r15, 1            ; siguiente bit en mapa de bits

    br    bucle_principal

no_comprime:
    ; Copiar carácter actual a zona3
    ld.b  r21, r10, r13
    st.b  r21, r16, r14
    addu  r13, r13, 1
    addu  r14, r14, 1
    addu  r15, r15, 1
    br    bucle_principal

fin_bucle:
    ;Registros importantes:
    ; r3 = longitud texto original
    ; r10 = dir texto original
    ; r11 = dir texto comprimido
    ; r12 = dir mapa bits
    ; r13 = índice en texto original
    ; r14 = índice en pilaZona3
    ; r15 = número de bit en mapa de bits
    ; r16 = dir zona3
    ; r21 = Tam mapa bits
    POP(r16)
    POP(r15)
    POP(r14)
    POP(r13)
    POP(r12)
    POP(r11)
    POP(r10)
    POP(r3)

    ; --- Copiar el mapa de bits ---
    ; r12 = inicio mapa de bits, r21 = Tamño en bytes
    or    r24, r0, 0
copiar_mapabits:
    cmp   r7, r24, r21
    bb1   ge, r7, fin_mapabits
    ld.b  r25, r16, r24        ; OJO: si el mapa de bits está en otra zona, ajusta el origen
    st.b  r25, r12, r24
    addu  r24, r24, 1
    br    copiar_mapabits
fin_mapabits:
    ; --- Copiar zona3 ---
    ; r16 = inicio zona3, r14 = longitud usada
    or    r24, r0, 0
    addu  r25, r12, r21        ; destino = inicio mapa de bits + tamaño mapa de bits
copiar_zona3:
    cmp   r7, r24, r14
    bb1   ge, r7, fin_zona3
    ld.b  r27, r16, r24
    st.b  r27, r25, r24
    addu  r24, r24, 1
    br    copiar_zona3
fin_zona3:

    ; --- Calcular longitud total y devolver ---
    addu  r2, r14, r21         ; zona3 + mapa de bits
    addu  r2, r2, 5            ; + cabecera
    ; r2 ya es el resultado

    ; --- Restaurar contexto y salir ---
    POP    (r31)
    POP    (r1)
    jmp (r1)
Descomprime:
    jmp (r1)
LeeBit:
    ; Guardar r1 y r31
    PUSH    (r1)                                    
    PUSH    (r31)                                   
    or      r31, r30, r0                             ; Marco de pila

    ; Cargar parámetros
    ld      r10, r31, 8                              ; r10 = dirZonaCB
    ld      r11, r31, 12                             ; r11 = NumBit
    or      r29,r0,0         

    ; byteOffset 
    divs     r12, r11, 8                            ; r12 = NumBit / 8      

    ; Obtener NumBit dentro del byte correspondiente
    or r18, r0, 8      ; Carga el valor 8 en r18

    mulu r18,r18,r12
    subu r13,r11,r18                                                                                                                
    or r14, r0, 7                                   ; r14 = 7
    subu r13, r14, r13                              ; r13 = 7 - r13 => posición de bit en el byte

    ; Preparar mascara
    or r3,r0,1                                      ;r3 = 1
    or r4,r0,2                                      ;r4 = 2

    addu r16, r10, r12                              ; r16 = dirZonaCB + byteOffset (dirección del byte)
    ld.bu r17, r16, r0                              ; r17 = contenido byte actual (lectura)
    cmp r7,r17,r0
    bb1 eq,r7,finLB


    ;Desplazar contenido byte a la dcha para dejar el bit x en posicion 0
    BucleLB1:
    cmp r7,r13,r0                                   ; Comprobamos si estamos en NumBit
    bb1 eq,r7,LB2                                   ; Si estamos => PBA1
    cmp r7,r17,r0
    bb1 eq,r7,LB2_0 
    divu r17,r17,r4                                 ; Desplazamos r17 un bit a la dcha
    subu r13,r13,1                                  ; Decrementamos contador de NumBit
    br BucleLB1

    LB2_0:
        or r29,r0,r0
        br finLB
    ;Aplicamos mascara
    LB2:
    and     r29,r17,r3                              ; Aplicamos mascara y guardamos en r29
    finLB:
    ; Restaurar pila y retornar
    POP(r31)
    POP(r1)
    jmp (r1)                                        ; Retorno

org 0xB000                                              ; dir donde se reserva campoBits
cadena: data "trestristes tigrescomentrigoenuntrigal, elprimertigreque...\0"
comprimido: data ""

;
; Debe incorporar este fichero con TODAS sus l�neas, sin modificar
; ninguna de ellas, al final de su archivo CDV24.ens
;
; Este aviso se refiere tambi�n a las l�neas de comentario
; 
;
;; Grupo:    s.munoz-guerra - Fri Oct 24 18:41:19 CEST 2025

BuscaMax:
	PUSH (r1)
	PUSH (r31)
	or   r31, r30, 0
	or   r28, r0, 0x3107
	PUSH (r28)

	ld   r10, r31, 8;  REF
	ld   r11, r31, 12; MAX
	ld   r12, r31, 16; Dir(JJ)

	sub  r5, r0, 1		; guarda -1 en *JJ por si no se
	st   r5, r12, 0		; encuentran coincidencias

	addu r27, r0, r0  ; P
	addu r28, r0, r0  ; L

BucBM:
	ld.bu r20, r10, r11	; C=REF(max)

				; Reserva registros que
				; necesita conservar
	PUSH (r28) 	    	; L
	PUSH (r11)	    	; MAX

	     		    	; Par�metros de BuscaCar
	PUSH (r27)	    	; P
	PUSH (r10)	    	; REF
	PUSH (r20)	   	; C
	bsr  BuscaCar
	POP  (r20)
	POP  (r10)
	POP  (r27)

	POP  (r11)		; Recupera registros
	POP  (r28)	        ; salvaguardados

	cmp  r5, r29, r11	; nuevo P es >= MAX ??
	bb1  hs, r5, finBM
	addu r27, r29, r0	; P = nuevo P
	
	addu r13, r10, r27	; *REF(P)
	addu r14, r10, r11 	; *REF(max)	

	PUSH (r11)     		; Reserva registros que
	PUSH (r10)		; necesita conservar
	PUSH (r28)
	PUSH (r27)
	
	PUSH (r14)		; Par�metros de CoincidenCad
	PUSH (r13)
	bsr  CoincidenCad
	POP  (r13)
	POP  (r14)
	
	POP  (r27)		; Recupera registros
	POP  (r28)		; salvaguardados
	POP  (r10)
	POP  (r11)

	cmp r5, r29, r28	; Comprueba si longitud > L
	bb1 le, r5, contBM	; Si no lo es, contin�a
	cmp r5, r29, 255	; Comprueba si longitud > 255
	bb1 le, r5, noLimBM	; Si no lo es, contin�a
	addu r29, r0, 255	; Si lo es, limita su valor a 255
	
noLimBM:
	addu r28, r29, r0	; actualiza L
	ld   r12, r31, 16	; Dir(JJ)
	st   r27, r12, r0	; actualiza P en *JJ
	bb1 ge, r5, finBM	; Si coincidencia >= 255 termina
contBM: 
	addu r27, r27, 1	; Pasa al siguiente car�cter
	cmp  r5, r27, r11	; Es P>=max ?
	bb1  hs, r5, finBM
	
	br   BucBM   		; Nueva b�squeda del primer car�cter

finBM:
	addu r29, r28, r0	; asigna L al valor de retorno r29
	  
	or   r27, r0, 0x66E
	POP  (r28)

	or   r30, r31, 0
	POP  (r31)
	POP  (r1)
	jmp  (r1)
;; Grupo:    s.munoz-guerra